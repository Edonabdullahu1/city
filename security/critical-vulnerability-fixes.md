# Critical Authentication Vulnerability Fixes

## ðŸ”´ IMMEDIATE ACTIONS REQUIRED

### 1. Remove Information Disclosure in Authentication Logs

**File:** `lib/auth.ts`  
**Risk:** HIGH - Production logs exposing sensitive data

**Current Vulnerable Code:**
```typescript
console.log('Authorize called with:', credentials?.email);
console.log('User found:', !!user);
console.log('No user or password');
console.log('Password valid:', isPasswordValid);
console.log('Returning user:', authUser);
console.log('JWT callback - user:', user);
console.log('JWT callback - token before:', token);
console.log('JWT callback - token after:', token);
console.log('Session callback - token:', token);
console.log('Session callback - session before:', session);
console.log('Session callback - session after:', session);
console.log('Redirect callback - url:', url, 'baseUrl:', baseUrl);
```

**SECURE FIX - Replace with:**
```typescript
// Remove all console.log statements and implement secure logging
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: 'logs/auth.log',
      level: 'info'
    })
  ]
});

// In authorize function - NO sensitive data
if (process.env.NODE_ENV === 'development') {
  logger.info('Authentication attempt', { 
    email: credentials?.email ? '[REDACTED]' : 'missing',
    timestamp: new Date().toISOString()
  });
}
```

### 2. Strengthen Password Policy

**Files:** `app/api/auth/register/route.ts`, `lib/services/authService.ts`  
**Risk:** HIGH - Weak passwords compromise account security

**Current Vulnerable Code:**
```typescript
.min(6, 'Password must be at least 6 characters long')
.regex(
  /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
  'Password must contain at least one uppercase letter, one lowercase letter, and one number'
)
```

**SECURE FIX - Replace with:**
```typescript
// Create strong password schema
const strongPasswordSchema = z.string()
  .min(12, 'Password must be at least 12 characters long')
  .max(128, 'Password must be less than 128 characters')
  .regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    'Password must contain uppercase, lowercase, number, and special character (@$!%*?&)'
  )
  .refine(
    (password) => !commonPasswords.includes(password.toLowerCase()),
    'Password is too common, please choose a stronger password'
  );

// Common passwords list (add to constants file)
const commonPasswords = [
  'password123', '123456789', 'qwerty123', 'admin123',
  'welcome123', 'password1', 'letmein123'
  // Add more common passwords
];
```

### 3. Fix JWT Token Security Configuration

**File:** `lib/auth.ts`  
**Risk:** HIGH - 30-day tokens create extended attack windows

**Current Vulnerable Code:**
```typescript
session: {
  strategy: 'jwt',
  maxAge: 30 * 24 * 60 * 60, // 30 days
}
```

**SECURE FIX - Replace with:**
```typescript
session: {
  strategy: 'jwt',
  maxAge: 15 * 60, // 15 minutes
  updateAge: 5 * 60, // Update every 5 minutes if active
},
jwt: {
  maxAge: 15 * 60, // 15 minutes
  secret: process.env.NEXTAUTH_SECRET,
},
cookies: {
  sessionToken: {
    name: process.env.NODE_ENV === 'production' 
      ? '__Secure-next-auth.session-token' 
      : 'next-auth.session-token',
    options: {
      httpOnly: true,
      sameSite: 'strict',
      path: '/',
      secure: process.env.NODE_ENV === 'production',
      domain: process.env.NODE_ENV === 'production' 
        ? process.env.COOKIE_DOMAIN 
        : undefined
    }
  },
  callbackUrl: {
    name: process.env.NODE_ENV === 'production'
      ? '__Secure-next-auth.callback-url'
      : 'next-auth.callback-url',
    options: {
      sameSite: 'strict',
      path: '/',
      secure: process.env.NODE_ENV === 'production'
    }
  },
  csrfToken: {
    name: process.env.NODE_ENV === 'production'
      ? '__Host-next-auth.csrf-token'
      : 'next-auth.csrf-token',
    options: {
      httpOnly: true,
      sameSite: 'strict',
      path: '/',
      secure: process.env.NODE_ENV === 'production'
    }
  }
}
```

### 4. Enable Authentication Middleware

**File:** `middleware.ts`  
**Risk:** HIGH - No centralized route protection

**Current Code:**
```typescript
export function middleware(request: NextRequest) {
  // Temporarily disabled i18n middleware to fix routing
  return NextResponse.next()
}
```

**SECURE FIX - Replace with:**
```typescript
import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth(
  function middleware(req) {
    const { pathname } = req.nextUrl;
    const token = req.nextauth.token;

    // Admin route protection
    if (pathname.startsWith('/admin') && token?.role !== 'ADMIN') {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }

    // Agent route protection
    if (pathname.startsWith('/agent') && !['AGENT', 'ADMIN'].includes(token?.role)) {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        const { pathname } = req.nextUrl;
        
        // Allow public routes
        if (pathname.startsWith('/auth') || 
            pathname.startsWith('/api/auth') || 
            pathname === '/' ||
            pathname.startsWith('/about') ||
            pathname.startsWith('/contact') ||
            pathname.startsWith('/search')) {
          return true;
        }

        // Require authentication for protected routes
        return !!token;
      },
    },
  }
);

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
```

### 5. Implement Rate Limiting

**Create:** `lib/auth/rateLimiting.ts`

```typescript
import { NextRequest } from 'next/server';

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
    blocked: boolean;
    blockUntil?: number;
  };
}

const store: RateLimitStore = {};
const LOGIN_ATTEMPTS_LIMIT = 5;
const LOGIN_WINDOW = 15 * 60 * 1000; // 15 minutes
const BLOCK_DURATION = 30 * 60 * 1000; // 30 minutes

export function checkRateLimit(
  request: NextRequest, 
  identifier: string
): { allowed: boolean; remainingAttempts: number; resetTime: number } {
  const now = Date.now();
  const key = `login:${identifier}`;
  
  if (!store[key]) {
    store[key] = {
      count: 0,
      resetTime: now + LOGIN_WINDOW,
      blocked: false
    };
  }

  const record = store[key];

  // Check if currently blocked
  if (record.blocked && record.blockUntil && now < record.blockUntil) {
    return {
      allowed: false,
      remainingAttempts: 0,
      resetTime: record.blockUntil
    };
  }

  // Reset window if expired
  if (now > record.resetTime) {
    record.count = 0;
    record.resetTime = now + LOGIN_WINDOW;
    record.blocked = false;
    record.blockUntil = undefined;
  }

  // Check limit
  if (record.count >= LOGIN_ATTEMPTS_LIMIT) {
    record.blocked = true;
    record.blockUntil = now + BLOCK_DURATION;
    return {
      allowed: false,
      remainingAttempts: 0,
      resetTime: record.blockUntil
    };
  }

  return {
    allowed: true,
    remainingAttempts: LOGIN_ATTEMPTS_LIMIT - record.count,
    resetTime: record.resetTime
  };
}

export function recordFailedAttempt(identifier: string): void {
  const key = `login:${identifier}`;
  if (store[key]) {
    store[key].count++;
  }
}

export function clearRateLimit(identifier: string): void {
  const key = `login:${identifier}`;
  delete store[key];
}
```

**Update:** `lib/auth.ts` to use rate limiting:

```typescript
async authorize(credentials) {
  if (!credentials?.email || !credentials?.password) {
    return null;
  }

  // Check rate limiting
  const rateLimitResult = checkRateLimit(request, credentials.email);
  if (!rateLimitResult.allowed) {
    throw new Error(`Too many login attempts. Try again in ${Math.ceil((rateLimitResult.resetTime - Date.now()) / 60000)} minutes.`);
  }

  try {
    const user = await prisma.user.findUnique({
      where: { email: credentials.email }
    });

    if (!user || !user.password) {
      recordFailedAttempt(credentials.email);
      return null;
    }

    const isPasswordValid = await bcrypt.compare(
      credentials.password,
      user.password
    );

    if (!isPasswordValid) {
      recordFailedAttempt(credentials.email);
      return null;
    }

    // Clear rate limit on successful login
    clearRateLimit(credentials.email);

    return {
      id: user.id,
      email: user.email,
      name: `${user.firstName} ${user.lastName}`,
      role: user.role,
    };
  } catch (error) {
    recordFailedAttempt(credentials.email);
    return null;
  }
}
```

### 6. Add Security Event Logging

**Create:** `lib/security/auditLogger.ts`

```typescript
import winston from 'winston';

const securityLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: 'logs/security-events.log',
      level: 'info'
    }),
    new winston.transports.File({ 
      filename: 'logs/security-errors.log',
      level: 'error'
    })
  ]
});

export enum SecurityEvent {
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILURE = 'LOGIN_FAILURE',
  REGISTRATION = 'REGISTRATION',
  PASSWORD_CHANGE = 'PASSWORD_CHANGE',
  ACCOUNT_LOCKED = 'ACCOUNT_LOCKED',
  UNAUTHORIZED_ACCESS = 'UNAUTHORIZED_ACCESS',
  PRIVILEGE_ESCALATION_ATTEMPT = 'PRIVILEGE_ESCALATION_ATTEMPT',
  SESSION_EXPIRED = 'SESSION_EXPIRED'
}

export interface SecurityEventData {
  event: SecurityEvent;
  userId?: string;
  userEmail?: string;
  userRole?: string;
  ipAddress?: string;
  userAgent?: string;
  resource?: string;
  details?: Record<string, any>;
}

export function logSecurityEvent(data: SecurityEventData): void {
  securityLogger.info('Security Event', {
    timestamp: new Date().toISOString(),
    event: data.event,
    userId: data.userId || 'anonymous',
    userEmail: data.userEmail ? '[REDACTED]' : undefined,
    userRole: data.userRole,
    ipAddress: data.ipAddress,
    userAgent: data.userAgent ? data.userAgent.substring(0, 100) : undefined,
    resource: data.resource,
    details: data.details
  });
}
```

### 7. Standardize Authorization with Secure Middleware

**Update:** `lib/auth/roleGuard.ts` - Add secure error handling:

```typescript
export async function withAuth(
  handler: (request: NextRequest, context?: any) => Promise<NextResponse>,
  allowedRoles?: UserRole[]
) {
  return async (request: NextRequest, context?: any) => {
    try {
      const token = await getToken({
        req: request,
        secret: process.env.NEXTAUTH_SECRET,
      });

      // Log unauthorized access attempts
      if (!token) {
        logSecurityEvent({
          event: SecurityEvent.UNAUTHORIZED_ACCESS,
          ipAddress: request.ip || 'unknown',
          userAgent: request.headers.get('user-agent') || 'unknown',
          resource: request.nextUrl.pathname
        });

        return NextResponse.json(
          { 
            success: false, 
            message: 'Authentication required',
            code: 'AUTH_REQUIRED'
          },
          { status: 401 }
        );
      }

      // Log privilege escalation attempts
      if (allowedRoles && allowedRoles.length > 0) {
        const userRole = token.role as UserRole;
        if (!allowedRoles.includes(userRole)) {
          logSecurityEvent({
            event: SecurityEvent.PRIVILEGE_ESCALATION_ATTEMPT,
            userId: token.sub,
            userRole: userRole,
            ipAddress: request.ip || 'unknown',
            userAgent: request.headers.get('user-agent') || 'unknown',
            resource: request.nextUrl.pathname,
            details: { requiredRoles: allowedRoles, userRole }
          });

          return NextResponse.json(
            { 
              success: false, 
              message: 'Insufficient permissions',
              code: 'INSUFFICIENT_PERMISSIONS'
            },
            { status: 403 }
          );
        }
      }

      const userContext = {
        user: {
          id: token.sub!,
          email: token.email!,
          role: token.role as UserRole,
        },
      };

      return handler(request, { ...context, ...userContext });
    } catch (error) {
      logSecurityEvent({
        event: SecurityEvent.UNAUTHORIZED_ACCESS,
        ipAddress: request.ip || 'unknown',
        userAgent: request.headers.get('user-agent') || 'unknown',
        resource: request.nextUrl.pathname,
        details: { error: error.message }
      });

      return NextResponse.json(
        { 
          success: false, 
          message: 'Authentication error',
          code: 'AUTH_ERROR'
        },
        { status: 500 }
      );
    }
  };
}
```

## ðŸ”§ IMPLEMENTATION CHECKLIST

- [ ] Remove all console.log statements from auth files
- [ ] Implement secure Winston logging
- [ ] Update password schema with 12-char minimum + special chars
- [ ] Add common password checking
- [ ] Configure secure JWT settings (15-minute expiry)
- [ ] Enable NextAuth middleware with route protection
- [ ] Implement rate limiting for login attempts
- [ ] Add security event logging system
- [ ] Update all API routes to use standardized auth middleware
- [ ] Test authentication flows after changes
- [ ] Deploy to staging for security testing
- [ ] Update environment variables for secure cookies

## ðŸš¨ POST-IMPLEMENTATION VERIFICATION

After implementing these fixes:

1. **Test Authentication Flow**
   - Verify login works with new password policy
   - Confirm rate limiting triggers after 5 failed attempts
   - Test JWT token expiration (should be 15 minutes)

2. **Test Authorization**
   - Verify role-based access control
   - Test unauthorized access attempts are logged
   - Confirm middleware blocks access to protected routes

3. **Security Testing**
   - Run security scan on authentication endpoints
   - Test for information disclosure in logs
   - Verify secure cookie settings in browser dev tools

**CRITICAL:** Test all changes in development environment before production deployment.